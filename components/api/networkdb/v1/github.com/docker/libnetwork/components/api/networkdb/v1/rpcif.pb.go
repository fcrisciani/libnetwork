// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1/rpcif.proto

/*
Package networkdb is a generated protocol buffer package.

It is generated from these files:
	v1/rpcif.proto

It has these top-level messages:
	InitializeRequest
	StateClusterResponse
	JoinClusterRequest
	PeersClusterResponse
	JoinGroupRequest
	LeaveGroupRequest
	PeerGroupRequest
	PeerGroupResponse
	CreateEntryRequest
	ReadEntryRequest
	ReadEntryResponse
	UpdateEntryRequest
	DeleteEntryRequest
	ReadTableRequest
	ReadTableResponse
	WatchTableRequest
	WatchTableEvent
	Group
	Table
	Entry
	Peer
*/
package networkdb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ** ClusterManagement **
type NodeState int32

const (
	// healthy state, everything looks good
	NodeState_HEALTHY NodeState = 0
	// experiencing some failure, performance is degradated but not unrecoverable
	NodeState_TRANSIENT_FAILURE NodeState = 1
	// criticl condition, the functionality is compromised
	NodeState_FAILED NodeState = 2
	// waiting for initialization
	NodeState_NOT_INITIALIZED NodeState = 3
)

var NodeState_name = map[int32]string{
	0: "HEALTHY",
	1: "TRANSIENT_FAILURE",
	2: "FAILED",
	3: "NOT_INITIALIZED",
}
var NodeState_value = map[string]int32{
	"HEALTHY":           0,
	"TRANSIENT_FAILURE": 1,
	"FAILED":            2,
	"NOT_INITIALIZED":   3,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}
func (NodeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type TableOperation int32

const (
	TableOperation_CREATE TableOperation = 0
	TableOperation_UPDATE TableOperation = 1
	TableOperation_DELETE TableOperation = 2
)

var TableOperation_name = map[int32]string{
	0: "CREATE",
	1: "UPDATE",
	2: "DELETE",
}
var TableOperation_value = map[string]int32{
	"CREATE": 0,
	"UPDATE": 1,
	"DELETE": 2,
}

func (x TableOperation) String() string {
	return proto.EnumName(TableOperation_name, int32(x))
}
func (TableOperation) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type InitializeRequest struct {
	// node_name is the cluster wide unique name for this node.
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// bind_addr is the IP on which networkdb listens.
	BindAddr string `protobuf:"bytes,2,opt,name=bind_addr,json=bindAddr" json:"bind_addr,omitempty"`
	// bind_port is the local node's port to which we bind to for cluster communication.
	BindPort int32 `protobuf:"varint,3,opt,name=bind_port,json=bindPort" json:"bind_port,omitempty"`
	// keys to be added to the Keyring of the memberlist. Key at index
	// 0 is the primary key
	Keys [][]byte `protobuf:"bytes,4,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *InitializeRequest) Reset()                    { *m = InitializeRequest{} }
func (m *InitializeRequest) String() string            { return proto.CompactTextString(m) }
func (*InitializeRequest) ProtoMessage()               {}
func (*InitializeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *InitializeRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *InitializeRequest) GetBindAddr() string {
	if m != nil {
		return m.BindAddr
	}
	return ""
}

func (m *InitializeRequest) GetBindPort() int32 {
	if m != nil {
		return m.BindPort
	}
	return 0
}

func (m *InitializeRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type StateClusterResponse struct {
	Status NodeState `protobuf:"varint,1,opt,name=status,enum=libnetwork.networkdb.v1.NodeState" json:"status,omitempty"`
}

func (m *StateClusterResponse) Reset()                    { *m = StateClusterResponse{} }
func (m *StateClusterResponse) String() string            { return proto.CompactTextString(m) }
func (*StateClusterResponse) ProtoMessage()               {}
func (*StateClusterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StateClusterResponse) GetStatus() NodeState {
	if m != nil {
		return m.Status
	}
	return NodeState_HEALTHY
}

type JoinClusterRequest struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *JoinClusterRequest) Reset()                    { *m = JoinClusterRequest{} }
func (m *JoinClusterRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinClusterRequest) ProtoMessage()               {}
func (*JoinClusterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *JoinClusterRequest) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type PeersClusterResponse struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *PeersClusterResponse) Reset()                    { *m = PeersClusterResponse{} }
func (m *PeersClusterResponse) String() string            { return proto.CompactTextString(m) }
func (*PeersClusterResponse) ProtoMessage()               {}
func (*PeersClusterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PeersClusterResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type JoinGroupRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=group_name,json=groupName" json:"group_name,omitempty"`
}

func (m *JoinGroupRequest) Reset()                    { *m = JoinGroupRequest{} }
func (m *JoinGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinGroupRequest) ProtoMessage()               {}
func (*JoinGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *JoinGroupRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

type LeaveGroupRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=group_name,json=groupName" json:"group_name,omitempty"`
}

func (m *LeaveGroupRequest) Reset()                    { *m = LeaveGroupRequest{} }
func (m *LeaveGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*LeaveGroupRequest) ProtoMessage()               {}
func (*LeaveGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LeaveGroupRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

type PeerGroupRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=group_name,json=groupName" json:"group_name,omitempty"`
}

func (m *PeerGroupRequest) Reset()                    { *m = PeerGroupRequest{} }
func (m *PeerGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*PeerGroupRequest) ProtoMessage()               {}
func (*PeerGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PeerGroupRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

type PeerGroupResponse struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *PeerGroupResponse) Reset()                    { *m = PeerGroupResponse{} }
func (m *PeerGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*PeerGroupResponse) ProtoMessage()               {}
func (*PeerGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PeerGroupResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type CreateEntryRequest struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *CreateEntryRequest) Reset()                    { *m = CreateEntryRequest{} }
func (m *CreateEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateEntryRequest) ProtoMessage()               {}
func (*CreateEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateEntryRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *CreateEntryRequest) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type ReadEntryRequest struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *ReadEntryRequest) Reset()                    { *m = ReadEntryRequest{} }
func (m *ReadEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadEntryRequest) ProtoMessage()               {}
func (*ReadEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ReadEntryRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ReadEntryRequest) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type ReadEntryResponse struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *ReadEntryResponse) Reset()                    { *m = ReadEntryResponse{} }
func (m *ReadEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadEntryResponse) ProtoMessage()               {}
func (*ReadEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ReadEntryResponse) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ReadEntryResponse) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type UpdateEntryRequest struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *UpdateEntryRequest) Reset()                    { *m = UpdateEntryRequest{} }
func (m *UpdateEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateEntryRequest) ProtoMessage()               {}
func (*UpdateEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UpdateEntryRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *UpdateEntryRequest) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type DeleteEntryRequest struct {
	Table *Table `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Entry *Entry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *DeleteEntryRequest) Reset()                    { *m = DeleteEntryRequest{} }
func (m *DeleteEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteEntryRequest) ProtoMessage()               {}
func (*DeleteEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeleteEntryRequest) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *DeleteEntryRequest) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type ReadTableRequest struct {
	Group     *Group `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
}

func (m *ReadTableRequest) Reset()                    { *m = ReadTableRequest{} }
func (m *ReadTableRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadTableRequest) ProtoMessage()               {}
func (*ReadTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ReadTableRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ReadTableRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

type ReadTableResponse struct {
	Table *Table   `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	List  []*Entry `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *ReadTableResponse) Reset()                    { *m = ReadTableResponse{} }
func (m *ReadTableResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadTableResponse) ProtoMessage()               {}
func (*ReadTableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ReadTableResponse) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *ReadTableResponse) GetList() []*Entry {
	if m != nil {
		return m.List
	}
	return nil
}

type WatchTableRequest struct {
	Group     *Group `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
}

func (m *WatchTableRequest) Reset()                    { *m = WatchTableRequest{} }
func (m *WatchTableRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchTableRequest) ProtoMessage()               {}
func (*WatchTableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *WatchTableRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *WatchTableRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

type WatchTableEvent struct {
	Operation TableOperation `protobuf:"varint,1,opt,name=operation,enum=libnetwork.networkdb.v1.TableOperation" json:"operation,omitempty"`
	Table     *Table         `protobuf:"bytes,2,opt,name=table" json:"table,omitempty"`
	Entry     *Entry         `protobuf:"bytes,3,opt,name=entry" json:"entry,omitempty"`
}

func (m *WatchTableEvent) Reset()                    { *m = WatchTableEvent{} }
func (m *WatchTableEvent) String() string            { return proto.CompactTextString(m) }
func (*WatchTableEvent) ProtoMessage()               {}
func (*WatchTableEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WatchTableEvent) GetOperation() TableOperation {
	if m != nil {
		return m.Operation
	}
	return TableOperation_CREATE
}

func (m *WatchTableEvent) GetTable() *Table {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *WatchTableEvent) GetEntry() *Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type Group struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName" json:"groupName,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Group) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

type Table struct {
	Group     *Group `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Table) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Table) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

type Entry struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Entry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Entry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Peer struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Ip   string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Peer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Peer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func init() {
	proto.RegisterType((*InitializeRequest)(nil), "libnetwork.networkdb.v1.InitializeRequest")
	proto.RegisterType((*StateClusterResponse)(nil), "libnetwork.networkdb.v1.StateClusterResponse")
	proto.RegisterType((*JoinClusterRequest)(nil), "libnetwork.networkdb.v1.JoinClusterRequest")
	proto.RegisterType((*PeersClusterResponse)(nil), "libnetwork.networkdb.v1.PeersClusterResponse")
	proto.RegisterType((*JoinGroupRequest)(nil), "libnetwork.networkdb.v1.JoinGroupRequest")
	proto.RegisterType((*LeaveGroupRequest)(nil), "libnetwork.networkdb.v1.LeaveGroupRequest")
	proto.RegisterType((*PeerGroupRequest)(nil), "libnetwork.networkdb.v1.PeerGroupRequest")
	proto.RegisterType((*PeerGroupResponse)(nil), "libnetwork.networkdb.v1.PeerGroupResponse")
	proto.RegisterType((*CreateEntryRequest)(nil), "libnetwork.networkdb.v1.CreateEntryRequest")
	proto.RegisterType((*ReadEntryRequest)(nil), "libnetwork.networkdb.v1.ReadEntryRequest")
	proto.RegisterType((*ReadEntryResponse)(nil), "libnetwork.networkdb.v1.ReadEntryResponse")
	proto.RegisterType((*UpdateEntryRequest)(nil), "libnetwork.networkdb.v1.UpdateEntryRequest")
	proto.RegisterType((*DeleteEntryRequest)(nil), "libnetwork.networkdb.v1.DeleteEntryRequest")
	proto.RegisterType((*ReadTableRequest)(nil), "libnetwork.networkdb.v1.ReadTableRequest")
	proto.RegisterType((*ReadTableResponse)(nil), "libnetwork.networkdb.v1.ReadTableResponse")
	proto.RegisterType((*WatchTableRequest)(nil), "libnetwork.networkdb.v1.WatchTableRequest")
	proto.RegisterType((*WatchTableEvent)(nil), "libnetwork.networkdb.v1.WatchTableEvent")
	proto.RegisterType((*Group)(nil), "libnetwork.networkdb.v1.Group")
	proto.RegisterType((*Table)(nil), "libnetwork.networkdb.v1.Table")
	proto.RegisterType((*Entry)(nil), "libnetwork.networkdb.v1.Entry")
	proto.RegisterType((*Peer)(nil), "libnetwork.networkdb.v1.Peer")
	proto.RegisterEnum("libnetwork.networkdb.v1.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("libnetwork.networkdb.v1.TableOperation", TableOperation_name, TableOperation_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ConfigurationManagement service

type ConfigurationManagementClient interface {
	// Component initialization
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type configurationManagementClient struct {
	cc *grpc.ClientConn
}

func NewConfigurationManagementClient(cc *grpc.ClientConn) ConfigurationManagementClient {
	return &configurationManagementClient{cc}
}

func (c *configurationManagementClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.ConfigurationManagement/Initialize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ConfigurationManagement service

type ConfigurationManagementServer interface {
	// Component initialization
	Initialize(context.Context, *InitializeRequest) (*google_protobuf.Empty, error)
}

func RegisterConfigurationManagementServer(s *grpc.Server, srv ConfigurationManagementServer) {
	s.RegisterService(&_ConfigurationManagement_serviceDesc, srv)
}

func _ConfigurationManagement_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationManagementServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.ConfigurationManagement/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationManagementServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigurationManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "libnetwork.networkdb.v1.ConfigurationManagement",
	HandlerType: (*ConfigurationManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _ConfigurationManagement_Initialize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/rpcif.proto",
}

// Client API for ClusterManagement service

type ClusterManagementClient interface {
	// Cluster related operations
	StateCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*StateClusterResponse, error)
	JoinCluster(ctx context.Context, in *JoinClusterRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	LeaveCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	PeersCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*PeersClusterResponse, error)
}

type clusterManagementClient struct {
	cc *grpc.ClientConn
}

func NewClusterManagementClient(cc *grpc.ClientConn) ClusterManagementClient {
	return &clusterManagementClient{cc}
}

func (c *clusterManagementClient) StateCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*StateClusterResponse, error) {
	out := new(StateClusterResponse)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.ClusterManagement/StateCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagementClient) JoinCluster(ctx context.Context, in *JoinClusterRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.ClusterManagement/JoinCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagementClient) LeaveCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.ClusterManagement/LeaveCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagementClient) PeersCluster(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*PeersClusterResponse, error) {
	out := new(PeersClusterResponse)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.ClusterManagement/PeersCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClusterManagement service

type ClusterManagementServer interface {
	// Cluster related operations
	StateCluster(context.Context, *google_protobuf.Empty) (*StateClusterResponse, error)
	JoinCluster(context.Context, *JoinClusterRequest) (*google_protobuf.Empty, error)
	LeaveCluster(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	PeersCluster(context.Context, *google_protobuf.Empty) (*PeersClusterResponse, error)
}

func RegisterClusterManagementServer(s *grpc.Server, srv ClusterManagementServer) {
	s.RegisterService(&_ClusterManagement_serviceDesc, srv)
}

func _ClusterManagement_StateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagementServer).StateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.ClusterManagement/StateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagementServer).StateCluster(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManagement_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagementServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.ClusterManagement/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagementServer).JoinCluster(ctx, req.(*JoinClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManagement_LeaveCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagementServer).LeaveCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.ClusterManagement/LeaveCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagementServer).LeaveCluster(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManagement_PeersCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagementServer).PeersCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.ClusterManagement/PeersCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagementServer).PeersCluster(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "libnetwork.networkdb.v1.ClusterManagement",
	HandlerType: (*ClusterManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StateCluster",
			Handler:    _ClusterManagement_StateCluster_Handler,
		},
		{
			MethodName: "JoinCluster",
			Handler:    _ClusterManagement_JoinCluster_Handler,
		},
		{
			MethodName: "LeaveCluster",
			Handler:    _ClusterManagement_LeaveCluster_Handler,
		},
		{
			MethodName: "PeersCluster",
			Handler:    _ClusterManagement_PeersCluster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/rpcif.proto",
}

// Client API for GroupManagement service

type GroupManagementClient interface {
	// // Group operations
	JoinGroup(ctx context.Context, in *JoinGroupRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	LeaveGroup(ctx context.Context, in *LeaveGroupRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	PeersGroup(ctx context.Context, in *PeerGroupRequest, opts ...grpc.CallOption) (*PeerGroupResponse, error)
}

type groupManagementClient struct {
	cc *grpc.ClientConn
}

func NewGroupManagementClient(cc *grpc.ClientConn) GroupManagementClient {
	return &groupManagementClient{cc}
}

func (c *groupManagementClient) JoinGroup(ctx context.Context, in *JoinGroupRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.GroupManagement/JoinGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupManagementClient) LeaveGroup(ctx context.Context, in *LeaveGroupRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.GroupManagement/LeaveGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupManagementClient) PeersGroup(ctx context.Context, in *PeerGroupRequest, opts ...grpc.CallOption) (*PeerGroupResponse, error) {
	out := new(PeerGroupResponse)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.GroupManagement/PeersGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GroupManagement service

type GroupManagementServer interface {
	// // Group operations
	JoinGroup(context.Context, *JoinGroupRequest) (*google_protobuf.Empty, error)
	LeaveGroup(context.Context, *LeaveGroupRequest) (*google_protobuf.Empty, error)
	PeersGroup(context.Context, *PeerGroupRequest) (*PeerGroupResponse, error)
}

func RegisterGroupManagementServer(s *grpc.Server, srv GroupManagementServer) {
	s.RegisterService(&_GroupManagement_serviceDesc, srv)
}

func _GroupManagement_JoinGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupManagementServer).JoinGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.GroupManagement/JoinGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupManagementServer).JoinGroup(ctx, req.(*JoinGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupManagement_LeaveGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupManagementServer).LeaveGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.GroupManagement/LeaveGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupManagementServer).LeaveGroup(ctx, req.(*LeaveGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupManagement_PeersGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupManagementServer).PeersGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.GroupManagement/PeersGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupManagementServer).PeersGroup(ctx, req.(*PeerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GroupManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "libnetwork.networkdb.v1.GroupManagement",
	HandlerType: (*GroupManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinGroup",
			Handler:    _GroupManagement_JoinGroup_Handler,
		},
		{
			MethodName: "LeaveGroup",
			Handler:    _GroupManagement_LeaveGroup_Handler,
		},
		{
			MethodName: "PeersGroup",
			Handler:    _GroupManagement_PeersGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/rpcif.proto",
}

// Client API for EntryManagement service

type EntryManagementClient interface {
	// Entry operations
	CreateEntryRpc(ctx context.Context, in *CreateEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	ReadEntryRpc(ctx context.Context, in *ReadEntryRequest, opts ...grpc.CallOption) (*ReadEntryResponse, error)
	UpdateEntryRpc(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	DeleteEntryRpc(ctx context.Context, in *DeleteEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Table operations
	ReadTable(ctx context.Context, in *ReadTableRequest, opts ...grpc.CallOption) (*ReadTableResponse, error)
	WatchTable(ctx context.Context, in *WatchTableRequest, opts ...grpc.CallOption) (EntryManagement_WatchTableClient, error)
}

type entryManagementClient struct {
	cc *grpc.ClientConn
}

func NewEntryManagementClient(cc *grpc.ClientConn) EntryManagementClient {
	return &entryManagementClient{cc}
}

func (c *entryManagementClient) CreateEntryRpc(ctx context.Context, in *CreateEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.EntryManagement/CreateEntryRpc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryManagementClient) ReadEntryRpc(ctx context.Context, in *ReadEntryRequest, opts ...grpc.CallOption) (*ReadEntryResponse, error) {
	out := new(ReadEntryResponse)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.EntryManagement/ReadEntryRpc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryManagementClient) UpdateEntryRpc(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.EntryManagement/UpdateEntryRpc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryManagementClient) DeleteEntryRpc(ctx context.Context, in *DeleteEntryRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.EntryManagement/DeleteEntryRpc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryManagementClient) ReadTable(ctx context.Context, in *ReadTableRequest, opts ...grpc.CallOption) (*ReadTableResponse, error) {
	out := new(ReadTableResponse)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.EntryManagement/ReadTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryManagementClient) WatchTable(ctx context.Context, in *WatchTableRequest, opts ...grpc.CallOption) (EntryManagement_WatchTableClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EntryManagement_serviceDesc.Streams[0], c.cc, "/libnetwork.networkdb.v1.EntryManagement/WatchTable", opts...)
	if err != nil {
		return nil, err
	}
	x := &entryManagementWatchTableClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EntryManagement_WatchTableClient interface {
	Recv() (*WatchTableEvent, error)
	grpc.ClientStream
}

type entryManagementWatchTableClient struct {
	grpc.ClientStream
}

func (x *entryManagementWatchTableClient) Recv() (*WatchTableEvent, error) {
	m := new(WatchTableEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EntryManagement service

type EntryManagementServer interface {
	// Entry operations
	CreateEntryRpc(context.Context, *CreateEntryRequest) (*google_protobuf.Empty, error)
	ReadEntryRpc(context.Context, *ReadEntryRequest) (*ReadEntryResponse, error)
	UpdateEntryRpc(context.Context, *UpdateEntryRequest) (*google_protobuf.Empty, error)
	DeleteEntryRpc(context.Context, *DeleteEntryRequest) (*google_protobuf.Empty, error)
	// Table operations
	ReadTable(context.Context, *ReadTableRequest) (*ReadTableResponse, error)
	WatchTable(*WatchTableRequest, EntryManagement_WatchTableServer) error
}

func RegisterEntryManagementServer(s *grpc.Server, srv EntryManagementServer) {
	s.RegisterService(&_EntryManagement_serviceDesc, srv)
}

func _EntryManagement_CreateEntryRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryManagementServer).CreateEntryRpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.EntryManagement/CreateEntryRpc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryManagementServer).CreateEntryRpc(ctx, req.(*CreateEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntryManagement_ReadEntryRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryManagementServer).ReadEntryRpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.EntryManagement/ReadEntryRpc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryManagementServer).ReadEntryRpc(ctx, req.(*ReadEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntryManagement_UpdateEntryRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryManagementServer).UpdateEntryRpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.EntryManagement/UpdateEntryRpc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryManagementServer).UpdateEntryRpc(ctx, req.(*UpdateEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntryManagement_DeleteEntryRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryManagementServer).DeleteEntryRpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.EntryManagement/DeleteEntryRpc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryManagementServer).DeleteEntryRpc(ctx, req.(*DeleteEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntryManagement_ReadTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryManagementServer).ReadTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.EntryManagement/ReadTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryManagementServer).ReadTable(ctx, req.(*ReadTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntryManagement_WatchTable_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchTableRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EntryManagementServer).WatchTable(m, &entryManagementWatchTableServer{stream})
}

type EntryManagement_WatchTableServer interface {
	Send(*WatchTableEvent) error
	grpc.ServerStream
}

type entryManagementWatchTableServer struct {
	grpc.ServerStream
}

func (x *entryManagementWatchTableServer) Send(m *WatchTableEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _EntryManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "libnetwork.networkdb.v1.EntryManagement",
	HandlerType: (*EntryManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEntryRpc",
			Handler:    _EntryManagement_CreateEntryRpc_Handler,
		},
		{
			MethodName: "ReadEntryRpc",
			Handler:    _EntryManagement_ReadEntryRpc_Handler,
		},
		{
			MethodName: "UpdateEntryRpc",
			Handler:    _EntryManagement_UpdateEntryRpc_Handler,
		},
		{
			MethodName: "DeleteEntryRpc",
			Handler:    _EntryManagement_DeleteEntryRpc_Handler,
		},
		{
			MethodName: "ReadTable",
			Handler:    _EntryManagement_ReadTable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchTable",
			Handler:       _EntryManagement_WatchTable_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/rpcif.proto",
}

// Client API for DiagnoseManagement service

type DiagnoseManagementClient interface {
	Ready(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type diagnoseManagementClient struct {
	cc *grpc.ClientConn
}

func NewDiagnoseManagementClient(cc *grpc.ClientConn) DiagnoseManagementClient {
	return &diagnoseManagementClient{cc}
}

func (c *diagnoseManagementClient) Ready(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/libnetwork.networkdb.v1.DiagnoseManagement/Ready", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DiagnoseManagement service

type DiagnoseManagementServer interface {
	Ready(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
}

func RegisterDiagnoseManagementServer(s *grpc.Server, srv DiagnoseManagementServer) {
	s.RegisterService(&_DiagnoseManagement_serviceDesc, srv)
}

func _DiagnoseManagement_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseManagementServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/libnetwork.networkdb.v1.DiagnoseManagement/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseManagementServer).Ready(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _DiagnoseManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "libnetwork.networkdb.v1.DiagnoseManagement",
	HandlerType: (*DiagnoseManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ready",
			Handler:    _DiagnoseManagement_Ready_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/rpcif.proto",
}

func init() { proto.RegisterFile("v1/rpcif.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1000 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xef, 0x6e, 0xe3, 0x44,
	0x10, 0x4f, 0x9c, 0xe4, 0x20, 0xd3, 0x28, 0x75, 0x96, 0xc2, 0x45, 0x39, 0x0e, 0x55, 0x96, 0x10,
	0x21, 0x08, 0x9b, 0xf8, 0xee, 0x0b, 0xf0, 0x85, 0x5c, 0x63, 0x68, 0x20, 0xa4, 0x91, 0xcf, 0x55,
	0xc5, 0x09, 0xa9, 0x72, 0xe2, 0xad, 0x6b, 0x35, 0xf1, 0x1a, 0x7b, 0x13, 0x14, 0x24, 0x0e, 0x9e,
	0x84, 0xa7, 0xe1, 0x0d, 0xf8, 0xcc, 0xbb, 0xa0, 0xdd, 0x4d, 0x62, 0xb7, 0x3e, 0x3b, 0xd7, 0x1e,
	0xd0, 0x4f, 0xde, 0xf5, 0xce, 0x9f, 0xdf, 0xcc, 0xce, 0xce, 0xfc, 0xa0, 0xbe, 0xec, 0x6a, 0x61,
	0x30, 0xf5, 0x2e, 0xd4, 0x20, 0x24, 0x94, 0xa0, 0x87, 0x33, 0x6f, 0xe2, 0x63, 0xfa, 0x33, 0x09,
	0xaf, 0xd4, 0xf5, 0xd7, 0x99, 0xa8, 0xcb, 0x6e, 0xeb, 0x91, 0x4b, 0x88, 0x3b, 0xc3, 0x1a, 0x17,
	0x9b, 0x2c, 0x2e, 0x34, 0x3c, 0x0f, 0xe8, 0x4a, 0x68, 0x29, 0x2f, 0xa1, 0x31, 0xf0, 0x3d, 0xea,
	0xd9, 0x33, 0xef, 0x17, 0x6c, 0xe2, 0x9f, 0x16, 0x38, 0xa2, 0xe8, 0x11, 0x54, 0x7d, 0xe2, 0xe0,
	0x73, 0xdf, 0x9e, 0xe3, 0x66, 0xf1, 0xb0, 0xd8, 0xae, 0x9a, 0x6f, 0xb3, 0x1f, 0x23, 0x7b, 0x8e,
	0xd9, 0xe1, 0xc4, 0xf3, 0x9d, 0x73, 0xdb, 0x71, 0xc2, 0xa6, 0x24, 0x0e, 0xd9, 0x8f, 0x9e, 0xe3,
	0x84, 0xdb, 0xc3, 0x80, 0x84, 0xb4, 0x59, 0x3a, 0x2c, 0xb6, 0x2b, 0xe2, 0x70, 0x4c, 0x42, 0x8a,
	0x10, 0x94, 0xaf, 0xf0, 0x2a, 0x6a, 0x96, 0x0f, 0x4b, 0xed, 0x9a, 0xc9, 0xd7, 0x8a, 0x09, 0x07,
	0xcf, 0xa9, 0x4d, 0xf1, 0xd1, 0x6c, 0x11, 0x51, 0x1c, 0x9a, 0x38, 0x0a, 0x88, 0x1f, 0x61, 0xf4,
	0x05, 0x3c, 0x88, 0xa8, 0x4d, 0x17, 0x11, 0xf7, 0x5f, 0xd7, 0x15, 0x35, 0x23, 0x3c, 0x75, 0x44,
	0x1c, 0xcc, 0x4d, 0x98, 0x6b, 0x0d, 0x65, 0x00, 0xe8, 0x5b, 0xe2, 0xf9, 0x5b, 0x93, 0x22, 0xa8,
	0x27, 0x50, 0x09, 0x30, 0x0e, 0x99, 0xc1, 0x52, 0x7b, 0x4f, 0x7f, 0x9c, 0x69, 0x70, 0x8c, 0x71,
	0x68, 0x0a, 0x59, 0xe5, 0x3b, 0x38, 0x60, 0xdb, 0xe8, 0x26, 0xbc, 0x3b, 0x19, 0xeb, 0x82, 0xcc,
	0x70, 0x7d, 0x13, 0x92, 0x45, 0xb0, 0x41, 0xf5, 0x18, 0xc0, 0x65, 0xfb, 0x64, 0xae, 0xab, 0xfc,
	0x0f, 0x4b, 0xb6, 0xa2, 0x43, 0x63, 0x88, 0xed, 0x25, 0xbe, 0x8d, 0x4e, 0x17, 0x64, 0xe6, 0xf5,
	0x36, 0x2a, 0xc7, 0xd0, 0x48, 0xa8, 0xbc, 0x49, 0x8c, 0xbf, 0x17, 0x01, 0x1d, 0x85, 0xd8, 0xa6,
	0xd8, 0xf0, 0x69, 0xb8, 0xda, 0xf8, 0x7f, 0x0a, 0x15, 0x6a, 0x4f, 0x66, 0xc2, 0xf5, 0x9e, 0xfe,
	0x41, 0xa6, 0x2d, 0x8b, 0x49, 0x99, 0x42, 0x98, 0x69, 0x61, 0x66, 0x85, 0x97, 0x59, 0x9e, 0x96,
	0xf0, 0x25, 0x84, 0x95, 0x97, 0x20, 0x9b, 0xd8, 0x76, 0xee, 0xcd, 0xff, 0x6f, 0xd0, 0x48, 0xf8,
	0x5f, 0x27, 0xf3, 0xff, 0x04, 0xc0, 0xee, 0xe0, 0x34, 0x70, 0xee, 0xf3, 0x0e, 0x18, 0x84, 0x3e,
	0x9e, 0xe1, 0x7b, 0x84, 0xe0, 0x8a, 0x32, 0x10, 0x96, 0x62, 0xff, 0xbc, 0xe8, 0x77, 0xfa, 0x17,
	0x2f, 0x41, 0x08, 0xb3, 0xc7, 0xc3, 0x81, 0x88, 0xc7, 0x23, 0x5a, 0x5e, 0x95, 0xff, 0xe1, 0x8f,
	0xe7, 0x57, 0x71, 0xdf, 0x6b, 0x47, 0x6f, 0x74, 0xdf, 0x3a, 0x94, 0x67, 0x5e, 0x44, 0x9b, 0x12,
	0x7f, 0x71, 0xbb, 0x02, 0xe5, 0xb2, 0xca, 0x25, 0x34, 0xce, 0x6c, 0x3a, 0xbd, 0xfc, 0xef, 0x03,
	0xfd, 0xb3, 0x08, 0xfb, 0xb1, 0x2b, 0x63, 0x89, 0x7d, 0x8a, 0x0c, 0xa8, 0x92, 0x00, 0x87, 0x36,
	0xf5, 0x88, 0xbf, 0x6e, 0xd5, 0x1f, 0xe5, 0xc7, 0x7a, 0xb2, 0x11, 0x37, 0x63, 0xcd, 0x38, 0x5d,
	0xd2, 0x9d, 0x0a, 0xa3, 0x74, 0x9b, 0xc2, 0xf8, 0x10, 0x2a, 0x3c, 0x6a, 0xf4, 0x3e, 0xc4, 0x2d,
	0x30, 0xdd, 0x13, 0x7f, 0x84, 0x8a, 0xb5, 0xf1, 0xf2, 0xef, 0xe7, 0x52, 0x83, 0x0a, 0x07, 0x85,
	0x64, 0x28, 0x5d, 0xe1, 0xd5, 0xda, 0x3d, 0x5b, 0xa2, 0x03, 0xa8, 0x2c, 0xed, 0xd9, 0x42, 0x28,
	0xd5, 0x4c, 0xb1, 0x51, 0x3a, 0x50, 0x66, 0x7d, 0x96, 0x0d, 0xd1, 0x44, 0x0f, 0xe7, 0x6b, 0x54,
	0x07, 0xc9, 0x0b, 0xd6, 0x3e, 0x24, 0x2f, 0xe8, 0x8c, 0xa1, 0xba, 0x9d, 0x8a, 0x68, 0x0f, 0xde,
	0x3a, 0x36, 0x7a, 0x43, 0xeb, 0xf8, 0x07, 0xb9, 0x80, 0xde, 0x85, 0x86, 0x65, 0xf6, 0x46, 0xcf,
	0x07, 0xc6, 0xc8, 0x3a, 0xff, 0xba, 0x37, 0x18, 0x9e, 0x9a, 0x86, 0x5c, 0x44, 0x00, 0x0f, 0xd8,
	0xc6, 0xe8, 0xcb, 0x12, 0x7a, 0x07, 0xf6, 0x47, 0x27, 0xd6, 0xf9, 0x60, 0x34, 0xb0, 0x06, 0xbd,
	0xe1, 0xe0, 0x85, 0xd1, 0x97, 0x4b, 0x9d, 0xa7, 0x50, 0xbf, 0x7e, 0x79, 0x4c, 0xe5, 0xc8, 0x34,
	0x7a, 0x96, 0x21, 0x17, 0xd8, 0xfa, 0x74, 0xdc, 0x67, 0x6b, 0x6e, 0xaa, 0x6f, 0x0c, 0x0d, 0xcb,
	0x90, 0x25, 0x7d, 0x0e, 0x0f, 0x8f, 0x88, 0x7f, 0xe1, 0xb9, 0x0b, 0xa1, 0xf4, 0xbd, 0xed, 0xdb,
	0x2e, 0x9e, 0xb3, 0xba, 0x31, 0x01, 0x62, 0xde, 0x81, 0x3a, 0x99, 0x39, 0x4d, 0x91, 0x93, 0xd6,
	0x7b, 0xaa, 0xe0, 0x33, 0xea, 0x86, 0xcf, 0xa8, 0x06, 0xe3, 0x33, 0x4a, 0x41, 0xff, 0x5b, 0x82,
	0xc6, 0x7a, 0x50, 0x27, 0x3c, 0x9d, 0x41, 0x2d, 0xc9, 0x30, 0x50, 0x86, 0x7e, 0xeb, 0xd3, 0x4c,
	0x0c, 0xaf, 0x22, 0x28, 0x4a, 0x01, 0x59, 0xb0, 0x97, 0xa0, 0x19, 0xe8, 0x93, 0x4c, 0xfd, 0x34,
	0x19, 0xc9, 0x0e, 0x02, 0x7d, 0x05, 0x35, 0x3e, 0xf1, 0x77, 0xc1, 0xcd, 0xb6, 0x70, 0x06, 0xb5,
	0x24, 0x67, 0xb9, 0x43, 0xc0, 0xaf, 0xa2, 0x3c, 0x4a, 0x41, 0xff, 0x43, 0x82, 0x7d, 0x5e, 0xe3,
	0x89, 0xec, 0x8e, 0xa1, 0xba, 0xe5, 0x34, 0xe8, 0xe3, 0xdc, 0x14, 0x24, 0x09, 0x49, 0x0e, 0x7c,
	0x13, 0x20, 0xa6, 0x3c, 0x39, 0x95, 0x91, 0xe2, 0x45, 0x39, 0x36, 0x31, 0x00, 0x8f, 0x69, 0x17,
	0xcc, 0x9b, 0xbc, 0xa9, 0xd5, 0x79, 0x1d, 0xd1, 0x6d, 0x82, 0xfe, 0x2a, 0xc3, 0x3e, 0x7f, 0xd5,
	0xd7, 0xca, 0xaf, 0x9e, 0xe4, 0x43, 0xc1, 0x34, 0xa7, 0x50, 0xd2, 0xc4, 0x29, 0x27, 0x26, 0x17,
	0x6a, 0x31, 0xcd, 0x08, 0xa6, 0x39, 0x51, 0xdd, 0x64, 0x43, 0x39, 0x51, 0xa5, 0x88, 0x0b, 0xaf,
	0xa7, 0x7a, 0x92, 0x4d, 0xe4, 0x46, 0x90, 0xa6, 0x1d, 0xb9, 0x85, 0x5a, 0x4f, 0x72, 0x84, 0x5c,
	0xc3, 0x69, 0x32, 0x91, 0x63, 0xd8, 0x81, 0xea, 0x76, 0x22, 0xef, 0xc8, 0x4b, 0x72, 0x6a, 0xee,
	0xc8, 0xcb, 0xb5, 0x01, 0xaf, 0x14, 0xd0, 0x05, 0x40, 0x3c, 0x0d, 0x73, 0x0a, 0x35, 0x35, 0x9d,
	0x5b, 0xed, 0xd7, 0x90, 0xe5, 0xe3, 0x55, 0x29, 0x7c, 0x56, 0xd4, 0x4f, 0x00, 0xf5, 0x3d, 0xdb,
	0xf5, 0x49, 0x84, 0x13, 0x75, 0xf5, 0x39, 0x54, 0x18, 0xa8, 0xd5, 0xed, 0x1b, 0xc4, 0xb3, 0xfe,
	0x8b, 0x67, 0xae, 0x47, 0x2f, 0x17, 0x13, 0x75, 0x4a, 0xe6, 0x9a, 0x43, 0xa6, 0x57, 0x38, 0xd4,
	0x62, 0x44, 0xda, 0x94, 0xcc, 0x03, 0xe2, 0x63, 0x9f, 0x46, 0x9a, 0x1d, 0x78, 0xda, 0x16, 0xa0,
	0xb6, 0xec, 0x7e, 0xb9, 0xdd, 0x4c, 0x1e, 0x70, 0xbb, 0x4f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff,
	0xb2, 0x30, 0x72, 0x2f, 0x88, 0x0e, 0x00, 0x00,
}
